# GitHub Copilot Instructions for Nirman Jashpur Backend

## Project Overview
This is a Node.js/Express.js backend API for managing construction work progress, orders, tenders, and administrative approvals in Jashpur district. The project uses MongoDB with Mongoose for data persistence.

## Architecture & Technology Stack
- **Runtime**: Node.js
- **Framework**: Express.js
- **Database**: MongoDB with Mongoose ODM
- **Authentication**: JWT (jsonwebtoken)
- **Validation**: express-validator
- **Security**: helmet, cors, express-rate-limit
- **Testing**: Jest with supertest and mongodb-memory-server
- **Development**: nodemon for hot reloading

## Project Structure
```
├── config/              # Configuration files
├── documentation/       # API documentation
├── middleware/          # Custom middleware (auth, error handling)
├── models/             # Mongoose schemas/models
├── routes/             # API route handlers
├── tests/              # Test files
├── utils/              # Utility functions and helpers
├── server.js           # Main application entry point
└── .env.example        # Environment variables template
```

## Coding Standards & Patterns

### 1. API Routes
- Use RESTful conventions (GET, POST, PUT, DELETE)
- Always include proper error handling with try-catch blocks
- Use express-validator for input validation
- Implement pagination for list endpoints (page, limit parameters)
- Include sorting and filtering capabilities
- Return consistent response format:
```javascript
{
  data: [...],
  pagination: { currentPage, totalPages, totalRecords, hasNext, hasPrev },
  message: "Success message",
  timestamp: "ISO date string"
}
```

### 2. Mongoose Models
- Include proper validation with custom error messages
- Use pre-save middleware for automatic timestamps
- Create appropriate database indexes for performance
- Include virtual properties where useful
- Follow naming convention: PascalCase for model names

### 3. Error Handling
- Use the centralized error handler in `middleware/errorHandler.js`
- Always validate ObjectIds before database operations
- Return appropriate HTTP status codes (400, 401, 403, 404, 500)
- Include validation errors in response when applicable

### 4. Security Practices
- Always validate and sanitize user input
- Use rate limiting on all routes
- Implement proper CORS configuration
- Use helmet for security headers
- Never expose sensitive information in error messages

### 5. Database Operations
- Use lean() for read-only operations to improve performance
- Implement proper aggregation pipelines for complex queries
- Use Promise.all() for parallel database operations
- Always handle MongoDB connection errors gracefully

## Key Models & Schemas

### WorkProgress
- Tracks construction work progress with stages: Pending, In Progress, Completed
- Required fields: workName, area, workAgency, scheme, technicalApproval, administrativeApproval, workProgressStage

### WorkOrder
- Manages work orders with status: Pending, Issued, Completed
- Automatically sets orderDate when status changes to 'Issued'
- Automatically sets completionDate when status changes to 'Completed'

### Tender
- Handles tender processes with status: Draft, Published, Bid Submission, Under Evaluation, Awarded, Cancelled
- Includes financial fields: tenderAmount, awardedAmount
- Has contractorName for awarded tenders

### AdministrativeApproval
- Manages approval workflows with status: Pending, Approved, Rejected, Under Review
- Includes approvalAuthority and approvalAmount fields
- Automatically sets approvalDate when status changes to 'Approved'

### WorkType
- Categorizes work types with department, engineer, priority levels
- Includes location fields: area, city, ward
- Has priority enum: Low, Medium, High, Critical

## Common Patterns & Helpers

### Validation Middleware
Always use validation arrays before route handlers:
```javascript
const validateWorkProgress = [
  body('workName').trim().notEmpty().withMessage('Work name is required'),
  body('area').trim().notEmpty().withMessage('Area is required'),
  // ... more validations
];
```

### Filter Building
Use the buildFilterQuery helper for consistent filtering:
```javascript
const buildFilterQuery = (queryParams) => {
  const filter = {};
  if (queryParams.area) filter.area = new RegExp(queryParams.area, 'i');
  if (queryParams.scheme) filter.scheme = new RegExp(queryParams.scheme, 'i');
  return filter;
};
```

### Pagination
Always implement pagination on list endpoints:
```javascript
const page = parseInt(req.query.page) || 1;
const limit = parseInt(req.query.limit) || 10;
const skip = (page - 1) * limit;
```

## Environment Variables
Reference these environment variables in configuration:
- `NODE_ENV` - Environment (development/production)
- `PORT` - Server port
- `MONGODB_URI` - MongoDB connection string
- `JWT_SECRET` - JWT secret key
- `FRONTEND_URL` - Frontend URL for CORS
- `RATE_LIMIT_WINDOW_MS` - Rate limiting window
- `RATE_LIMIT_MAX_REQUESTS` - Max requests per window

## Testing Guidelines
- Use Jest with supertest for API testing
- Use mongodb-memory-server for isolated test database
- Test all CRUD operations
- Test error scenarios (invalid IDs, validation failures)
- Test authentication and authorization
- Include setup and teardown in test files

## API Endpoints Convention
Base URL: `/api/v1`

Standard CRUD patterns:
- `GET /{resource}` - List with pagination, filtering, sorting
- `GET /{resource}/:id` - Get single resource
- `POST /{resource}` - Create new resource
- `PUT /{resource}/:id` - Update resource
- `DELETE /{resource}/:id` - Delete resource

Special endpoints:
- `GET /reports/{type}` - Generate reports
- `GET /health` - Health check

## Performance Considerations
- Use database indexes on frequently queried fields
- Implement lean() queries for read-only operations
- Use aggregation pipelines for complex data transformations
- Cache frequently accessed data where appropriate
- Implement proper connection pooling for MongoDB

## Security Considerations
- Always validate input data
- Use parameterized queries (Mongoose handles this)
- Implement rate limiting
- Use HTTPS in production
- Store JWT secrets securely
- Implement proper CORS policies

## When Adding New Features
1. Create/update Mongoose models with proper validation
2. Implement route handlers with full CRUD operations
3. Add input validation using express-validator
4. Include proper error handling
5. Write comprehensive tests
6. Update API documentation
7. Consider performance and security implications

## Common Imports
```javascript
const express = require('express');
const { body, validationResult, query } = require('express-validator');
const Model = require('../models/ModelName');
```

## Response Format Standards
Success responses:
```javascript
res.json({
  data: result,
  pagination: paginationInfo, // for list endpoints
  message: 'Operation successful'
});
```

Error responses:
```javascript
res.status(statusCode).json({
  message: 'Error description',
  errors: validationErrors, // if applicable
  timestamp: new Date().toISOString()
});
```

This backend follows enterprise-level patterns for scalability, maintainability, and security. Always consider these guidelines when suggesting code improvements or new features.
